; traffic_light_final.asm
; Authors : Kailas Ugenskas
; Desc    : Traffic light control with System Tick Interrupt (Req #3 fulfilled)
;    
; declare constants      
; ------------------------------------------------------------
; Timer0 10ms Tick Calculation:
; 16MHz / 1024 Prescaler = 15,625 ticks/sec
; 10ms = 156.25 ticks -> Use 156 for OCR0A
.equ TICK_COMPARE = 156

; Set variables to pin names
.equ NS_GREEN = PB2
.equ NS_YELLOW = PB3
.equ NS_RED = PB4
.equ NS_CROSS = PB1
.equ NS_DONT_CROSS = PB0

.equ EW_GREEN = PC3
.equ EW_YELLOW = PC2
.equ EW_RED = PC1
.equ EW_CROSS = PC4
.equ EW_DONT_CROSS = PC5

.equ EW_BUTTON = PD2
.equ NS_BUTTON = PD3

; Register Definitions
.def walkRequested_EW = r21
.def walkRequested_NS = r22
.def system_ticks     = r25  ; we increment this using the timer interrupt


; vector table
; ------------------------------------------------------------
.org 0x0000
          jmp       main

.org 0x0002                     ; INT0 (EW Button)
          jmp       Button_EW_ISR

.org 0x0004                     ; INT1 (NS Button)
          jmp       Button_NS_ISR

.org 0x001C                     ; TIMER0 COMPA (System Tick)
          jmp       Timer_Tick_ISR

.org INT_VECTORS_SIZE


; main config
; ------------------------------------------------------------
main:
          ; Stack Setup
          ldi       r16, high(RAMEND)
          out       SPH, r16
          ldi       r16, low(RAMEND)
          out       SPL, r16
          
          ; GPIO Setup (Output mode)
          sbi       DDRB, NS_GREEN
          sbi       DDRB, NS_YELLOW
          sbi       DDRB, NS_RED
          sbi       DDRB, NS_CROSS
          sbi       DDRB, NS_DONT_CROSS

          sbi       DDRC, EW_GREEN
          sbi       DDRC, EW_YELLOW
          sbi       DDRC, EW_RED
          sbi       DDRC, EW_CROSS
          sbi       DDRC, EW_DONT_CROSS

          ; Button Setup (Inputs + Pullups)
          cbi       DDRD, EW_BUTTON
          sbi       PORTD, EW_BUTTON
          cbi       DDRD, NS_BUTTON
          sbi       PORTD, NS_BUTTON

          ; interrupt setup
          ; INT0/INT1 Falling Edge
          ldi       r16, (1 << ISC11) | (1 << ISC01)
          sts       EICRA, r16
          ldi       r16, (1 << INT1) | (1 << INT0)
          out       EIMSK, r16

          ; timer setup
          ; Configure Timer0 for CTC Mode, Prescaler 1024, 10ms interrupts
          ldi       r16, TICK_COMPARE
          out       OCR0A, r16
          
          ; WGM01 = 1 (CTC Mode)
          ldi       r16, (1 << WGM01)
          out       TCCR0A, r16
          
          ; CS02=1 and CS00=1 (Prescaler 1024)
          ldi       r16, (1 << CS02) | (1 << CS00)
          out       TCCR0B, r16

          ; Enable Timer0 Compare A Interrupt
          ldi       r16, (1 << OCIE0A)
          sts       TIMSK0, r16

          clr       walkRequested_NS
          clr       walkRequested_EW
          clr       system_ticks
          
          sei


; main loop
; ------------------------------------------------------------
main_loop:

NS_Traffic_Cycle:
          call      set_ns_green
          call      set_ew_red
          
          ; Green for 5 seconds (2 x 2.5s)
          call      delay_250_ticks
          call      delay_250_ticks_check_ew  ; Check EW button to cut short
          
          ; Yellow
          call      set_ns_yellow
          call      delay_250_ticks     ; ~2.5s
          
          ; Red (Both should be red)
          ; They are both red in this instance in case somebody runs a red light, so there's a buffer time for it to turn green
          call      set_ns_red          ; ns is set to red
          call      set_ew_red          ; ew is set to red

          
          ; check NS walk
          cpi       walkRequested_NS, 1
          brne      skip_ns_walk
          
          ; This is what the crosswalk is going to look like
          sbi       PORTC, PC1
          call      delay_250_ticks
          call      delay_250_ticks
          cbi       PORTC, PC1
          sbi       PORTC, PC3  
          sbi       PORTB, NS_CROSS
          cbi       PORTB, NS_DONT_CROSS
          ; EW stays Red.
          
          ; Solid White for 5s total (2.5s + 2.5s)
          call      delay_250_ticks
          call      delay_250_ticks
          cbi       PORTC, PC3
          sbi       PORTC, PC2
          call      delay_250_ticks
          call      delay_250_ticks
          cbi       PORTC, PC2
          cbi       PORTC, PC3
          sbi       PORTC, PC1
          call      delay_250_ticks
          ; End Walk
          cbi       PORTB, NS_CROSS
          sbi       PORTB, NS_DONT_CROSS
          clr       walkRequested_NS
          
          ; Both red for aafety buffer
          call      delay_250_ticks
          rjmp      EW_Traffic_Cycle   ; Skip the normal red wait

skip_ns_walk:
          ; safety delay for when they're both red
          call      delay_250_ticks
          
EW_Traffic_Cycle:
          call      set_ew_green
          call      set_ns_red
          
          ; Green 5s
          call      delay_250_ticks
          call      delay_250_ticks_check_ns
          
          ; Yellow
          call      set_ew_yellow
          call      delay_250_ticks
          
          ; Red (when they're both red)
          call      set_ew_red
          call      set_ns_red
          
          ; check ew walk
          cpi       walkRequested_EW, 1
          brne      skip_ew_walk
          
          ; checks EW walk
          sbi       PORTB, PB4                    ;keep red light on
          call      delay_250_ticks               ; wait for all the cars to pass with these delays so all the lights are red
          call      delay_250_ticks
          cbi       PORTB, PB4                    ; turn red light off
          sbi       PORTB, PB2                    ; turn on ns_green_light
          sbi       PORTC, EW_CROSS               ; turn on cross walk sign
          cbi       PORTC, EW_DONT_CROSS          ; turn off "do not cross sign"
          
          ; Solid White for 5s total
          call      delay_250_ticks
          call      delay_250_ticks
          cbi       PORTB, PB2                    ; turn off ns_green light
          sbi       PORTB, PB3                    ; turn on ns_yellow light 
          call      delay_250_ticks
          call      delay_250_ticks
          cbi       PORTB, PB3                    ; turn off ns_yellow light      
          sbi       PORTB, PB4                    ; turn on ns_red light

          ; end of the crosswalk
          cbi       PORTC, EW_CROSS               ; turn off cross sign
          sbi       PORTC, EW_DONT_CROSS          ; turn on cross sign
          call      delay_250_ticks               ; delay for 5 seconds in total

          
          ; End Walk
          clr       walkRequested_EW
          
          rjmp      NS_Traffic_Cycle

skip_ew_walk:
          call      delay_250_ticks
          rjmp      NS_Traffic_Cycle


; ISR
; ------------------------------------------------------------
Button_EW_ISR:
          push      r16
          in        r16, SREG
          push      r16
          ldi       walkRequested_EW, 1
          pop       r16
          out       SREG, r16
          pop       r16
          reti

Button_NS_ISR:
          push      r16
          in        r16, SREG
          push      r16
          ldi       walkRequested_NS, 1
          pop       r16
          out       SREG, r16
          pop       r16
          reti

Timer_Tick_ISR:
          
          push      r16
          in        r16, SREG
          push      r16
          
          inc       system_ticks      ; Increment the tick counter (r25)
          
          pop       r16
          out       SREG, r16
          pop       r16
          reti


; delay functions (we use tick counter)
; ------------------------------------------------------------
delay_250_ticks:
          ; Wait for system_ticks to count up to 250 (2.5 seconds)
          clr       system_ticks      ; Reset the counter
wait_250:
          cpi       system_ticks, 250 ; Have we reached 250 ticks?
          brne      wait_250          ; If not, keep waiting
          ret

delay_250_ticks_check_ew:
          clr       system_ticks
wait_250_ew:
          cpi       walkRequested_EW, 1  ; Check button flag
          breq      exit_delay           ; Exit early if pressed
          cpi       system_ticks, 250
          brne      wait_250_ew
exit_delay:
          ret

delay_250_ticks_check_ns:
          clr       system_ticks
wait_250_ns:
          cpi       walkRequested_NS, 1
          breq      exit_delay
          cpi       system_ticks, 250
          brne      wait_250_ns
          ret

; led light set functions
; ------------------------------------------------------------
set_ns_green:
          sbi PORTB, NS_GREEN
          cbi PORTB, NS_YELLOW
          cbi PORTB, NS_RED
          sbi PORTB, NS_DONT_CROSS
          cbi PORTB, NS_CROSS
          ret
set_ns_yellow:
          cbi PORTB, NS_GREEN
          sbi PORTB, NS_YELLOW
          cbi PORTB, NS_RED
          sbi PORTB, NS_DONT_CROSS
          cbi PORTB, NS_CROSS
          ret
set_ns_red:
          cbi PORTB, NS_GREEN
          cbi PORTB, NS_YELLOW
          sbi PORTB, NS_RED
          sbi PORTB, NS_DONT_CROSS
          cbi PORTB, NS_CROSS
          ret
set_ew_green:
          sbi PORTC, EW_GREEN
          cbi PORTC, EW_YELLOW
          cbi PORTC, EW_RED
          sbi PORTC, EW_DONT_CROSS
          cbi PORTC, EW_CROSS
          ret
set_ew_yellow:
          cbi PORTC, EW_GREEN
          sbi PORTC, EW_YELLOW
          cbi PORTC, EW_RED
          sbi PORTC, EW_DONT_CROSS
          cbi PORTC, EW_CROSS
          ret
set_ew_red:
          cbi PORTC, EW_GREEN
          cbi PORTC, EW_YELLOW
          sbi PORTC, EW_RED
          sbi PORTC, EW_DONT_CROSS
          cbi PORTC, EW_CROSS
          ret
